<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ES6 对象的扩展方法</title>
</head>
<body>
<script>
/*

//属性简写
    var foo = 'bar';
    var baz = {foo};
    console.log(baz)

//    方法简写

    var  o ={
    method:function(){
        console.log('我是一个方法')
    }
}

var  o ={

   method(){
       console.log('我是一个方法')
   }
}


var  birth = '2013/33/454';
    var person = {
        name:'cd',
        birth,
        getname(){
            return thia.name;
        }
    }

   function getPoint(){
        var  x=1;
       var b = 2;
       return {x,b}
}

getPoint()
// {x:1, y:10}

var obj = {
    * m(){
        yield 'hello world';
    }
};
//如果是对象 默认情况下会将对象直接转化为字符串[object,object]
const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
    [keyA]: 'valueA',
    [keyB]: 'valueB'
};

//myObject // Object {[object Object]: "valueB"}
//上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。


//    方法的name属性

/!*
    const person ={
        sayName(){
            console.log('ppp')
        }
    }
person.sayName.name
*!/

/!*
ES5比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。
它们都有缺点，前者会自动转换数据类型，
后者的NaN不等于自身，以及+0等于-0。JavaScript缺乏一种运算，在所有环境中，
只要两个值是一样的，它们就应该相等。
*!/
// Object.is() 同值相等 用来比较两个值是否严格相等，与严格比较运算符（===） 行为基本一致
console.log(Object.is('foo','foo'))
console.log(Object.is({},{}))


//    不同之处就是-0 ！=+0  NAN = NAN

console.log(Object.is(-0,+0)) // FALSE
console.log(Object.is(NaN,NaN))//TRUE
var target = { a: 1 };

var source1 = { b: 2 };
var source2 = { c: 3 };

console.log(Object.assign(target,source1,source2))


//    如果只有一个参数，Object.assign会直接返回该参数
var obj = {a: 1};
console.log(Object.assign(obj) === obj )// true
//如果该参数不是对象，则会先转成对象，然后返回。

typeof Object.assign(2) // "object"

//Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。
//Object.assign是浅拷贝 拷贝的是对象的引用

var obj1 = {a: {b: 1}};
var obj2 = Object.assign({}, obj1);
obj1.a.b = 2;
    console.log(obj2.a.b)


//    Object.assign()用途
//    为对象添加属性
    class point(){
        constructor(x,y){
            Object.assign(this,{x,y})
    }
}
*/

//上面方法通过Object.assign方法，将x属性和y属性添加到Point类的对象实例。


//    为对象添加方法
/*
    Object.assign(someClass.prototype,{
        someMethod(){
            console.log('yyy')
        },
        anthorMethod(){
            console.log('fghjkl')
        }
    })

// 等同于下面的写法
SomeClass.prototype.someMethod = function (arg1, arg2) {

};
SomeClass.prototype.anotherMethod = function () {

};

//克隆对象
    function clone(origin){
        return Object.assign({},origin)
    }*/

//    将原对象拷贝到空对象上就得到了对象的克隆

//不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。


/*function clone(origin) {
    let originProto = Object.getPrototypeOf(origin);
    return Object.assign(Object.create(originProto), origin);
}*/


//属性的可没枚举性
let obj = { foo: 123 };
console.log(Object.getOwnPropertyDescriptor(obj,'foo'))


/*
for...in循环：只遍历对象自身的和继承的可枚举的属性
Object.keys()：返回对象自身的所有可枚举的属性的键名
JSON.stringify()：只串行化对象自身的可枚举的属性
*/
//另外，ES6规定，所有Class的原型的方法都是不可枚举的。


//    ES6 的遍历
//  for in
//
//Object.keys()
//
//Object.getOwnPropertyNames()
//
////将proto设置为obj的原型
//Object.setPrototypeOf(obj, proto);
//Object.getPrototypeOf()

var obj = { foo: 'bar', baz: 42 };
console.log(Object.keys(obj))
/*
const firstName = (message
        && message.body
        && message.body.user
        && message.body.user.firstName) || 'default';
Null 传导运算符
const firstName = message?.body?.user?.firstName || 'default';
*/

</script>
</body>
</html>